// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'html_text_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$HtmlTextResultData {
  String? get text => throw _privateConstructorUsedError;
  bool get isActuallyHaveHtmlInData => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $HtmlTextResultDataCopyWith<HtmlTextResultData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HtmlTextResultDataCopyWith<$Res> {
  factory $HtmlTextResultDataCopyWith(
          HtmlTextResultData value, $Res Function(HtmlTextResultData) then) =
      _$HtmlTextResultDataCopyWithImpl<$Res, HtmlTextResultData>;
  @useResult
  $Res call({String? text, bool isActuallyHaveHtmlInData});
}

/// @nodoc
class _$HtmlTextResultDataCopyWithImpl<$Res, $Val extends HtmlTextResultData>
    implements $HtmlTextResultDataCopyWith<$Res> {
  _$HtmlTextResultDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? text = freezed,
    Object? isActuallyHaveHtmlInData = null,
  }) {
    return _then(_value.copyWith(
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      isActuallyHaveHtmlInData: null == isActuallyHaveHtmlInData
          ? _value.isActuallyHaveHtmlInData
          : isActuallyHaveHtmlInData // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$HtmlTextResultDataImplCopyWith<$Res>
    implements $HtmlTextResultDataCopyWith<$Res> {
  factory _$$HtmlTextResultDataImplCopyWith(_$HtmlTextResultDataImpl value,
          $Res Function(_$HtmlTextResultDataImpl) then) =
      __$$HtmlTextResultDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? text, bool isActuallyHaveHtmlInData});
}

/// @nodoc
class __$$HtmlTextResultDataImplCopyWithImpl<$Res>
    extends _$HtmlTextResultDataCopyWithImpl<$Res, _$HtmlTextResultDataImpl>
    implements _$$HtmlTextResultDataImplCopyWith<$Res> {
  __$$HtmlTextResultDataImplCopyWithImpl(_$HtmlTextResultDataImpl _value,
      $Res Function(_$HtmlTextResultDataImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? text = freezed,
    Object? isActuallyHaveHtmlInData = null,
  }) {
    return _then(_$HtmlTextResultDataImpl(
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      isActuallyHaveHtmlInData: null == isActuallyHaveHtmlInData
          ? _value.isActuallyHaveHtmlInData
          : isActuallyHaveHtmlInData // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$HtmlTextResultDataImpl implements _HtmlTextResultData {
  const _$HtmlTextResultDataImpl(
      {required this.text, required this.isActuallyHaveHtmlInData});

  @override
  final String? text;
  @override
  final bool isActuallyHaveHtmlInData;

  @override
  String toString() {
    return 'HtmlTextResultData(text: $text, isActuallyHaveHtmlInData: $isActuallyHaveHtmlInData)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HtmlTextResultDataImpl &&
            (identical(other.text, text) || other.text == text) &&
            (identical(
                    other.isActuallyHaveHtmlInData, isActuallyHaveHtmlInData) ||
                other.isActuallyHaveHtmlInData == isActuallyHaveHtmlInData));
  }

  @override
  int get hashCode => Object.hash(runtimeType, text, isActuallyHaveHtmlInData);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HtmlTextResultDataImplCopyWith<_$HtmlTextResultDataImpl> get copyWith =>
      __$$HtmlTextResultDataImplCopyWithImpl<_$HtmlTextResultDataImpl>(
          this, _$identity);
}

abstract class _HtmlTextResultData implements HtmlTextResultData {
  const factory _HtmlTextResultData(
      {required final String? text,
      required final bool isActuallyHaveHtmlInData}) = _$HtmlTextResultDataImpl;

  @override
  String? get text;
  @override
  bool get isActuallyHaveHtmlInData;
  @override
  @JsonKey(ignore: true)
  _$$HtmlTextResultDataImplCopyWith<_$HtmlTextResultDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$HtmlTextInputData {
  String? get input => throw _privateConstructorUsedError;
  List<IUnifediApiEmoji>? get emojis => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $HtmlTextInputDataCopyWith<HtmlTextInputData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HtmlTextInputDataCopyWith<$Res> {
  factory $HtmlTextInputDataCopyWith(
          HtmlTextInputData value, $Res Function(HtmlTextInputData) then) =
      _$HtmlTextInputDataCopyWithImpl<$Res, HtmlTextInputData>;
  @useResult
  $Res call({String? input, List<IUnifediApiEmoji>? emojis});
}

/// @nodoc
class _$HtmlTextInputDataCopyWithImpl<$Res, $Val extends HtmlTextInputData>
    implements $HtmlTextInputDataCopyWith<$Res> {
  _$HtmlTextInputDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = freezed,
    Object? emojis = freezed,
  }) {
    return _then(_value.copyWith(
      input: freezed == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as String?,
      emojis: freezed == emojis
          ? _value.emojis
          : emojis // ignore: cast_nullable_to_non_nullable
              as List<IUnifediApiEmoji>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$HtmlTextInputDataImplCopyWith<$Res>
    implements $HtmlTextInputDataCopyWith<$Res> {
  factory _$$HtmlTextInputDataImplCopyWith(_$HtmlTextInputDataImpl value,
          $Res Function(_$HtmlTextInputDataImpl) then) =
      __$$HtmlTextInputDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? input, List<IUnifediApiEmoji>? emojis});
}

/// @nodoc
class __$$HtmlTextInputDataImplCopyWithImpl<$Res>
    extends _$HtmlTextInputDataCopyWithImpl<$Res, _$HtmlTextInputDataImpl>
    implements _$$HtmlTextInputDataImplCopyWith<$Res> {
  __$$HtmlTextInputDataImplCopyWithImpl(_$HtmlTextInputDataImpl _value,
      $Res Function(_$HtmlTextInputDataImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = freezed,
    Object? emojis = freezed,
  }) {
    return _then(_$HtmlTextInputDataImpl(
      input: freezed == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as String?,
      emojis: freezed == emojis
          ? _value._emojis
          : emojis // ignore: cast_nullable_to_non_nullable
              as List<IUnifediApiEmoji>?,
    ));
  }
}

/// @nodoc

class _$HtmlTextInputDataImpl extends _HtmlTextInputData {
  const _$HtmlTextInputDataImpl(
      {required this.input, required final List<IUnifediApiEmoji>? emojis})
      : _emojis = emojis,
        super._();

  @override
  final String? input;
  final List<IUnifediApiEmoji>? _emojis;
  @override
  List<IUnifediApiEmoji>? get emojis {
    final value = _emojis;
    if (value == null) return null;
    if (_emojis is EqualUnmodifiableListView) return _emojis;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'HtmlTextInputData(input: $input, emojis: $emojis)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HtmlTextInputDataImpl &&
            (identical(other.input, input) || other.input == input) &&
            const DeepCollectionEquality().equals(other._emojis, _emojis));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, input, const DeepCollectionEquality().hash(_emojis));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HtmlTextInputDataImplCopyWith<_$HtmlTextInputDataImpl> get copyWith =>
      __$$HtmlTextInputDataImplCopyWithImpl<_$HtmlTextInputDataImpl>(
          this, _$identity);
}

abstract class _HtmlTextInputData extends HtmlTextInputData {
  const factory _HtmlTextInputData(
      {required final String? input,
      required final List<IUnifediApiEmoji>? emojis}) = _$HtmlTextInputDataImpl;
  const _HtmlTextInputData._() : super._();

  @override
  String? get input;
  @override
  List<IUnifediApiEmoji>? get emojis;
  @override
  @JsonKey(ignore: true)
  _$$HtmlTextInputDataImplCopyWith<_$HtmlTextInputDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$HtmlTextSettings {
  double? get fontSize => throw _privateConstructorUsedError;
  FontWeight? get fontWeight => throw _privateConstructorUsedError;
  double? get lineHeight => throw _privateConstructorUsedError;
  Color? get color => throw _privateConstructorUsedError;
  Color get linkColor => throw _privateConstructorUsedError;
  int? get textMaxLines => throw _privateConstructorUsedError;
  TextOverflow? get textOverflow => throw _privateConstructorUsedError;
  bool get shrinkWrap => throw _privateConstructorUsedError;
  bool get drawNewLines => throw _privateConstructorUsedError;
  TextAlign get textAlign =>
      throw _privateConstructorUsedError; // ignore: no-magic-number
  double get customEmojiImageSize =>
      throw _privateConstructorUsedError; // ignore: no-magic-number
  double get imageSize => throw _privateConstructorUsedError;
  Display get paragraphDisplay => throw _privateConstructorUsedError;
  double get textScaleFactor => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $HtmlTextSettingsCopyWith<HtmlTextSettings> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HtmlTextSettingsCopyWith<$Res> {
  factory $HtmlTextSettingsCopyWith(
          HtmlTextSettings value, $Res Function(HtmlTextSettings) then) =
      _$HtmlTextSettingsCopyWithImpl<$Res, HtmlTextSettings>;
  @useResult
  $Res call(
      {double? fontSize,
      FontWeight? fontWeight,
      double? lineHeight,
      Color? color,
      Color linkColor,
      int? textMaxLines,
      TextOverflow? textOverflow,
      bool shrinkWrap,
      bool drawNewLines,
      TextAlign textAlign,
      double customEmojiImageSize,
      double imageSize,
      Display paragraphDisplay,
      double textScaleFactor});
}

/// @nodoc
class _$HtmlTextSettingsCopyWithImpl<$Res, $Val extends HtmlTextSettings>
    implements $HtmlTextSettingsCopyWith<$Res> {
  _$HtmlTextSettingsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fontSize = freezed,
    Object? fontWeight = freezed,
    Object? lineHeight = freezed,
    Object? color = freezed,
    Object? linkColor = null,
    Object? textMaxLines = freezed,
    Object? textOverflow = freezed,
    Object? shrinkWrap = null,
    Object? drawNewLines = null,
    Object? textAlign = null,
    Object? customEmojiImageSize = null,
    Object? imageSize = null,
    Object? paragraphDisplay = null,
    Object? textScaleFactor = null,
  }) {
    return _then(_value.copyWith(
      fontSize: freezed == fontSize
          ? _value.fontSize
          : fontSize // ignore: cast_nullable_to_non_nullable
              as double?,
      fontWeight: freezed == fontWeight
          ? _value.fontWeight
          : fontWeight // ignore: cast_nullable_to_non_nullable
              as FontWeight?,
      lineHeight: freezed == lineHeight
          ? _value.lineHeight
          : lineHeight // ignore: cast_nullable_to_non_nullable
              as double?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      linkColor: null == linkColor
          ? _value.linkColor
          : linkColor // ignore: cast_nullable_to_non_nullable
              as Color,
      textMaxLines: freezed == textMaxLines
          ? _value.textMaxLines
          : textMaxLines // ignore: cast_nullable_to_non_nullable
              as int?,
      textOverflow: freezed == textOverflow
          ? _value.textOverflow
          : textOverflow // ignore: cast_nullable_to_non_nullable
              as TextOverflow?,
      shrinkWrap: null == shrinkWrap
          ? _value.shrinkWrap
          : shrinkWrap // ignore: cast_nullable_to_non_nullable
              as bool,
      drawNewLines: null == drawNewLines
          ? _value.drawNewLines
          : drawNewLines // ignore: cast_nullable_to_non_nullable
              as bool,
      textAlign: null == textAlign
          ? _value.textAlign
          : textAlign // ignore: cast_nullable_to_non_nullable
              as TextAlign,
      customEmojiImageSize: null == customEmojiImageSize
          ? _value.customEmojiImageSize
          : customEmojiImageSize // ignore: cast_nullable_to_non_nullable
              as double,
      imageSize: null == imageSize
          ? _value.imageSize
          : imageSize // ignore: cast_nullable_to_non_nullable
              as double,
      paragraphDisplay: null == paragraphDisplay
          ? _value.paragraphDisplay
          : paragraphDisplay // ignore: cast_nullable_to_non_nullable
              as Display,
      textScaleFactor: null == textScaleFactor
          ? _value.textScaleFactor
          : textScaleFactor // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$HtmlTextSettingsImplCopyWith<$Res>
    implements $HtmlTextSettingsCopyWith<$Res> {
  factory _$$HtmlTextSettingsImplCopyWith(_$HtmlTextSettingsImpl value,
          $Res Function(_$HtmlTextSettingsImpl) then) =
      __$$HtmlTextSettingsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double? fontSize,
      FontWeight? fontWeight,
      double? lineHeight,
      Color? color,
      Color linkColor,
      int? textMaxLines,
      TextOverflow? textOverflow,
      bool shrinkWrap,
      bool drawNewLines,
      TextAlign textAlign,
      double customEmojiImageSize,
      double imageSize,
      Display paragraphDisplay,
      double textScaleFactor});
}

/// @nodoc
class __$$HtmlTextSettingsImplCopyWithImpl<$Res>
    extends _$HtmlTextSettingsCopyWithImpl<$Res, _$HtmlTextSettingsImpl>
    implements _$$HtmlTextSettingsImplCopyWith<$Res> {
  __$$HtmlTextSettingsImplCopyWithImpl(_$HtmlTextSettingsImpl _value,
      $Res Function(_$HtmlTextSettingsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fontSize = freezed,
    Object? fontWeight = freezed,
    Object? lineHeight = freezed,
    Object? color = freezed,
    Object? linkColor = null,
    Object? textMaxLines = freezed,
    Object? textOverflow = freezed,
    Object? shrinkWrap = null,
    Object? drawNewLines = null,
    Object? textAlign = null,
    Object? customEmojiImageSize = null,
    Object? imageSize = null,
    Object? paragraphDisplay = null,
    Object? textScaleFactor = null,
  }) {
    return _then(_$HtmlTextSettingsImpl(
      fontSize: freezed == fontSize
          ? _value.fontSize
          : fontSize // ignore: cast_nullable_to_non_nullable
              as double?,
      fontWeight: freezed == fontWeight
          ? _value.fontWeight
          : fontWeight // ignore: cast_nullable_to_non_nullable
              as FontWeight?,
      lineHeight: freezed == lineHeight
          ? _value.lineHeight
          : lineHeight // ignore: cast_nullable_to_non_nullable
              as double?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      linkColor: null == linkColor
          ? _value.linkColor
          : linkColor // ignore: cast_nullable_to_non_nullable
              as Color,
      textMaxLines: freezed == textMaxLines
          ? _value.textMaxLines
          : textMaxLines // ignore: cast_nullable_to_non_nullable
              as int?,
      textOverflow: freezed == textOverflow
          ? _value.textOverflow
          : textOverflow // ignore: cast_nullable_to_non_nullable
              as TextOverflow?,
      shrinkWrap: null == shrinkWrap
          ? _value.shrinkWrap
          : shrinkWrap // ignore: cast_nullable_to_non_nullable
              as bool,
      drawNewLines: null == drawNewLines
          ? _value.drawNewLines
          : drawNewLines // ignore: cast_nullable_to_non_nullable
              as bool,
      textAlign: null == textAlign
          ? _value.textAlign
          : textAlign // ignore: cast_nullable_to_non_nullable
              as TextAlign,
      customEmojiImageSize: null == customEmojiImageSize
          ? _value.customEmojiImageSize
          : customEmojiImageSize // ignore: cast_nullable_to_non_nullable
              as double,
      imageSize: null == imageSize
          ? _value.imageSize
          : imageSize // ignore: cast_nullable_to_non_nullable
              as double,
      paragraphDisplay: null == paragraphDisplay
          ? _value.paragraphDisplay
          : paragraphDisplay // ignore: cast_nullable_to_non_nullable
              as Display,
      textScaleFactor: null == textScaleFactor
          ? _value.textScaleFactor
          : textScaleFactor // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$HtmlTextSettingsImpl implements _HtmlTextSettings {
  const _$HtmlTextSettingsImpl(
      {required this.fontSize,
      required this.fontWeight,
      required this.lineHeight,
      required this.color,
      required this.linkColor,
      required this.textMaxLines,
      required this.textOverflow,
      this.shrinkWrap = false,
      required this.drawNewLines,
      this.textAlign = TextAlign.start,
      this.customEmojiImageSize = 20.0,
      this.imageSize = 20.0,
      this.paragraphDisplay = Display.inline,
      required this.textScaleFactor});

  @override
  final double? fontSize;
  @override
  final FontWeight? fontWeight;
  @override
  final double? lineHeight;
  @override
  final Color? color;
  @override
  final Color linkColor;
  @override
  final int? textMaxLines;
  @override
  final TextOverflow? textOverflow;
  @override
  @JsonKey()
  final bool shrinkWrap;
  @override
  final bool drawNewLines;
  @override
  @JsonKey()
  final TextAlign textAlign;
// ignore: no-magic-number
  @override
  @JsonKey()
  final double customEmojiImageSize;
// ignore: no-magic-number
  @override
  @JsonKey()
  final double imageSize;
  @override
  @JsonKey()
  final Display paragraphDisplay;
  @override
  final double textScaleFactor;

  @override
  String toString() {
    return 'HtmlTextSettings(fontSize: $fontSize, fontWeight: $fontWeight, lineHeight: $lineHeight, color: $color, linkColor: $linkColor, textMaxLines: $textMaxLines, textOverflow: $textOverflow, shrinkWrap: $shrinkWrap, drawNewLines: $drawNewLines, textAlign: $textAlign, customEmojiImageSize: $customEmojiImageSize, imageSize: $imageSize, paragraphDisplay: $paragraphDisplay, textScaleFactor: $textScaleFactor)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HtmlTextSettingsImpl &&
            (identical(other.fontSize, fontSize) ||
                other.fontSize == fontSize) &&
            (identical(other.fontWeight, fontWeight) ||
                other.fontWeight == fontWeight) &&
            (identical(other.lineHeight, lineHeight) ||
                other.lineHeight == lineHeight) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.linkColor, linkColor) ||
                other.linkColor == linkColor) &&
            (identical(other.textMaxLines, textMaxLines) ||
                other.textMaxLines == textMaxLines) &&
            (identical(other.textOverflow, textOverflow) ||
                other.textOverflow == textOverflow) &&
            (identical(other.shrinkWrap, shrinkWrap) ||
                other.shrinkWrap == shrinkWrap) &&
            (identical(other.drawNewLines, drawNewLines) ||
                other.drawNewLines == drawNewLines) &&
            (identical(other.textAlign, textAlign) ||
                other.textAlign == textAlign) &&
            (identical(other.customEmojiImageSize, customEmojiImageSize) ||
                other.customEmojiImageSize == customEmojiImageSize) &&
            (identical(other.imageSize, imageSize) ||
                other.imageSize == imageSize) &&
            (identical(other.paragraphDisplay, paragraphDisplay) ||
                other.paragraphDisplay == paragraphDisplay) &&
            (identical(other.textScaleFactor, textScaleFactor) ||
                other.textScaleFactor == textScaleFactor));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      fontSize,
      fontWeight,
      lineHeight,
      color,
      linkColor,
      textMaxLines,
      textOverflow,
      shrinkWrap,
      drawNewLines,
      textAlign,
      customEmojiImageSize,
      imageSize,
      paragraphDisplay,
      textScaleFactor);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HtmlTextSettingsImplCopyWith<_$HtmlTextSettingsImpl> get copyWith =>
      __$$HtmlTextSettingsImplCopyWithImpl<_$HtmlTextSettingsImpl>(
          this, _$identity);
}

abstract class _HtmlTextSettings implements HtmlTextSettings {
  const factory _HtmlTextSettings(
      {required final double? fontSize,
      required final FontWeight? fontWeight,
      required final double? lineHeight,
      required final Color? color,
      required final Color linkColor,
      required final int? textMaxLines,
      required final TextOverflow? textOverflow,
      final bool shrinkWrap,
      required final bool drawNewLines,
      final TextAlign textAlign,
      final double customEmojiImageSize,
      final double imageSize,
      final Display paragraphDisplay,
      required final double textScaleFactor}) = _$HtmlTextSettingsImpl;

  @override
  double? get fontSize;
  @override
  FontWeight? get fontWeight;
  @override
  double? get lineHeight;
  @override
  Color? get color;
  @override
  Color get linkColor;
  @override
  int? get textMaxLines;
  @override
  TextOverflow? get textOverflow;
  @override
  bool get shrinkWrap;
  @override
  bool get drawNewLines;
  @override
  TextAlign get textAlign;
  @override // ignore: no-magic-number
  double get customEmojiImageSize;
  @override // ignore: no-magic-number
  double get imageSize;
  @override
  Display get paragraphDisplay;
  @override
  double get textScaleFactor;
  @override
  @JsonKey(ignore: true)
  _$$HtmlTextSettingsImplCopyWith<_$HtmlTextSettingsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
