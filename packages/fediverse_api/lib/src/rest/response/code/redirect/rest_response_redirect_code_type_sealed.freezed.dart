// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'rest_response_redirect_code_type_sealed.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$RestResponseRedirectCodeType {
  int get intValue => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int intValue)? multipleChoice,
    TResult? Function(int intValue)? moved,
    TResult? Function(int intValue)? found,
    TResult? Function(int intValue)? seeOther,
    TResult? Function(int intValue)? notModified,
    TResult? Function(int intValue)? useProxy,
    TResult? Function(int intValue)? unused,
    TResult? Function(int intValue)? temporaryRedirect,
    TResult? Function(int intValue)? permanentRedirect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MultipleChoice value)? multipleChoice,
    TResult? Function(_Moved value)? moved,
    TResult? Function(_Found value)? found,
    TResult? Function(_SeeOther value)? seeOther,
    TResult? Function(_NotModified value)? notModified,
    TResult? Function(_UseProxy value)? useProxy,
    TResult? Function(_Unused value)? unused,
    TResult? Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult? Function(_PermanentRedirect value)? permanentRedirect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $RestResponseRedirectCodeTypeCopyWith<RestResponseRedirectCodeType>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory $RestResponseRedirectCodeTypeCopyWith(
          RestResponseRedirectCodeType value,
          $Res Function(RestResponseRedirectCodeType) then) =
      _$RestResponseRedirectCodeTypeCopyWithImpl<$Res,
          RestResponseRedirectCodeType>;
  @useResult
  $Res call({int intValue});
}

/// @nodoc
class _$RestResponseRedirectCodeTypeCopyWithImpl<$Res,
        $Val extends RestResponseRedirectCodeType>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  _$RestResponseRedirectCodeTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intValue = null,
  }) {
    return _then(_value.copyWith(
      intValue: null == intValue
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MultipleChoiceImplCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$$MultipleChoiceImplCopyWith(_$MultipleChoiceImpl value,
          $Res Function(_$MultipleChoiceImpl) then) =
      __$$MultipleChoiceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int intValue});
}

/// @nodoc
class __$$MultipleChoiceImplCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res,
        _$MultipleChoiceImpl> implements _$$MultipleChoiceImplCopyWith<$Res> {
  __$$MultipleChoiceImplCopyWithImpl(
      _$MultipleChoiceImpl _value, $Res Function(_$MultipleChoiceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intValue = null,
  }) {
    return _then(_$MultipleChoiceImpl(
      intValue: null == intValue
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$MultipleChoiceImpl implements _MultipleChoice {
  const _$MultipleChoiceImpl(
      {this.intValue = RestResponseRedirectCodeType.multipleChoiceIntValue});

  @override
  @JsonKey()
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.multipleChoice(intValue: $intValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MultipleChoiceImpl &&
            (identical(other.intValue, intValue) ||
                other.intValue == intValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, intValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MultipleChoiceImplCopyWith<_$MultipleChoiceImpl> get copyWith =>
      __$$MultipleChoiceImplCopyWithImpl<_$MultipleChoiceImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return multipleChoice(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int intValue)? multipleChoice,
    TResult? Function(int intValue)? moved,
    TResult? Function(int intValue)? found,
    TResult? Function(int intValue)? seeOther,
    TResult? Function(int intValue)? notModified,
    TResult? Function(int intValue)? useProxy,
    TResult? Function(int intValue)? unused,
    TResult? Function(int intValue)? temporaryRedirect,
    TResult? Function(int intValue)? permanentRedirect,
  }) {
    return multipleChoice?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (multipleChoice != null) {
      return multipleChoice(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return multipleChoice(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MultipleChoice value)? multipleChoice,
    TResult? Function(_Moved value)? moved,
    TResult? Function(_Found value)? found,
    TResult? Function(_SeeOther value)? seeOther,
    TResult? Function(_NotModified value)? notModified,
    TResult? Function(_UseProxy value)? useProxy,
    TResult? Function(_Unused value)? unused,
    TResult? Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult? Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return multipleChoice?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (multipleChoice != null) {
      return multipleChoice(this);
    }
    return orElse();
  }
}

abstract class _MultipleChoice implements RestResponseRedirectCodeType {
  const factory _MultipleChoice({final int intValue}) = _$MultipleChoiceImpl;

  @override
  int get intValue;
  @override
  @JsonKey(ignore: true)
  _$$MultipleChoiceImplCopyWith<_$MultipleChoiceImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MovedImplCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$$MovedImplCopyWith(
          _$MovedImpl value, $Res Function(_$MovedImpl) then) =
      __$$MovedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int intValue});
}

/// @nodoc
class __$$MovedImplCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res, _$MovedImpl>
    implements _$$MovedImplCopyWith<$Res> {
  __$$MovedImplCopyWithImpl(
      _$MovedImpl _value, $Res Function(_$MovedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intValue = null,
  }) {
    return _then(_$MovedImpl(
      intValue: null == intValue
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$MovedImpl implements _Moved {
  const _$MovedImpl(
      {this.intValue = RestResponseRedirectCodeType.movedIntValue});

  @override
  @JsonKey()
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.moved(intValue: $intValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MovedImpl &&
            (identical(other.intValue, intValue) ||
                other.intValue == intValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, intValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MovedImplCopyWith<_$MovedImpl> get copyWith =>
      __$$MovedImplCopyWithImpl<_$MovedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return moved(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int intValue)? multipleChoice,
    TResult? Function(int intValue)? moved,
    TResult? Function(int intValue)? found,
    TResult? Function(int intValue)? seeOther,
    TResult? Function(int intValue)? notModified,
    TResult? Function(int intValue)? useProxy,
    TResult? Function(int intValue)? unused,
    TResult? Function(int intValue)? temporaryRedirect,
    TResult? Function(int intValue)? permanentRedirect,
  }) {
    return moved?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (moved != null) {
      return moved(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return moved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MultipleChoice value)? multipleChoice,
    TResult? Function(_Moved value)? moved,
    TResult? Function(_Found value)? found,
    TResult? Function(_SeeOther value)? seeOther,
    TResult? Function(_NotModified value)? notModified,
    TResult? Function(_UseProxy value)? useProxy,
    TResult? Function(_Unused value)? unused,
    TResult? Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult? Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return moved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (moved != null) {
      return moved(this);
    }
    return orElse();
  }
}

abstract class _Moved implements RestResponseRedirectCodeType {
  const factory _Moved({final int intValue}) = _$MovedImpl;

  @override
  int get intValue;
  @override
  @JsonKey(ignore: true)
  _$$MovedImplCopyWith<_$MovedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FoundImplCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$$FoundImplCopyWith(
          _$FoundImpl value, $Res Function(_$FoundImpl) then) =
      __$$FoundImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int intValue});
}

/// @nodoc
class __$$FoundImplCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res, _$FoundImpl>
    implements _$$FoundImplCopyWith<$Res> {
  __$$FoundImplCopyWithImpl(
      _$FoundImpl _value, $Res Function(_$FoundImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intValue = null,
  }) {
    return _then(_$FoundImpl(
      intValue: null == intValue
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$FoundImpl implements _Found {
  const _$FoundImpl(
      {this.intValue = RestResponseRedirectCodeType.foundIntValue});

  @override
  @JsonKey()
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.found(intValue: $intValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FoundImpl &&
            (identical(other.intValue, intValue) ||
                other.intValue == intValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, intValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FoundImplCopyWith<_$FoundImpl> get copyWith =>
      __$$FoundImplCopyWithImpl<_$FoundImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return found(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int intValue)? multipleChoice,
    TResult? Function(int intValue)? moved,
    TResult? Function(int intValue)? found,
    TResult? Function(int intValue)? seeOther,
    TResult? Function(int intValue)? notModified,
    TResult? Function(int intValue)? useProxy,
    TResult? Function(int intValue)? unused,
    TResult? Function(int intValue)? temporaryRedirect,
    TResult? Function(int intValue)? permanentRedirect,
  }) {
    return found?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (found != null) {
      return found(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return found(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MultipleChoice value)? multipleChoice,
    TResult? Function(_Moved value)? moved,
    TResult? Function(_Found value)? found,
    TResult? Function(_SeeOther value)? seeOther,
    TResult? Function(_NotModified value)? notModified,
    TResult? Function(_UseProxy value)? useProxy,
    TResult? Function(_Unused value)? unused,
    TResult? Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult? Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return found?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (found != null) {
      return found(this);
    }
    return orElse();
  }
}

abstract class _Found implements RestResponseRedirectCodeType {
  const factory _Found({final int intValue}) = _$FoundImpl;

  @override
  int get intValue;
  @override
  @JsonKey(ignore: true)
  _$$FoundImplCopyWith<_$FoundImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SeeOtherImplCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$$SeeOtherImplCopyWith(
          _$SeeOtherImpl value, $Res Function(_$SeeOtherImpl) then) =
      __$$SeeOtherImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int intValue});
}

/// @nodoc
class __$$SeeOtherImplCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res, _$SeeOtherImpl>
    implements _$$SeeOtherImplCopyWith<$Res> {
  __$$SeeOtherImplCopyWithImpl(
      _$SeeOtherImpl _value, $Res Function(_$SeeOtherImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intValue = null,
  }) {
    return _then(_$SeeOtherImpl(
      intValue: null == intValue
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SeeOtherImpl implements _SeeOther {
  const _$SeeOtherImpl(
      {this.intValue = RestResponseRedirectCodeType.seeOtherIntValue});

  @override
  @JsonKey()
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.seeOther(intValue: $intValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SeeOtherImpl &&
            (identical(other.intValue, intValue) ||
                other.intValue == intValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, intValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SeeOtherImplCopyWith<_$SeeOtherImpl> get copyWith =>
      __$$SeeOtherImplCopyWithImpl<_$SeeOtherImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return seeOther(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int intValue)? multipleChoice,
    TResult? Function(int intValue)? moved,
    TResult? Function(int intValue)? found,
    TResult? Function(int intValue)? seeOther,
    TResult? Function(int intValue)? notModified,
    TResult? Function(int intValue)? useProxy,
    TResult? Function(int intValue)? unused,
    TResult? Function(int intValue)? temporaryRedirect,
    TResult? Function(int intValue)? permanentRedirect,
  }) {
    return seeOther?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (seeOther != null) {
      return seeOther(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return seeOther(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MultipleChoice value)? multipleChoice,
    TResult? Function(_Moved value)? moved,
    TResult? Function(_Found value)? found,
    TResult? Function(_SeeOther value)? seeOther,
    TResult? Function(_NotModified value)? notModified,
    TResult? Function(_UseProxy value)? useProxy,
    TResult? Function(_Unused value)? unused,
    TResult? Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult? Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return seeOther?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (seeOther != null) {
      return seeOther(this);
    }
    return orElse();
  }
}

abstract class _SeeOther implements RestResponseRedirectCodeType {
  const factory _SeeOther({final int intValue}) = _$SeeOtherImpl;

  @override
  int get intValue;
  @override
  @JsonKey(ignore: true)
  _$$SeeOtherImplCopyWith<_$SeeOtherImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NotModifiedImplCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$$NotModifiedImplCopyWith(
          _$NotModifiedImpl value, $Res Function(_$NotModifiedImpl) then) =
      __$$NotModifiedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int intValue});
}

/// @nodoc
class __$$NotModifiedImplCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res, _$NotModifiedImpl>
    implements _$$NotModifiedImplCopyWith<$Res> {
  __$$NotModifiedImplCopyWithImpl(
      _$NotModifiedImpl _value, $Res Function(_$NotModifiedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intValue = null,
  }) {
    return _then(_$NotModifiedImpl(
      intValue: null == intValue
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$NotModifiedImpl implements _NotModified {
  const _$NotModifiedImpl(
      {this.intValue = RestResponseRedirectCodeType.notModifiedIntValue});

  @override
  @JsonKey()
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.notModified(intValue: $intValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotModifiedImpl &&
            (identical(other.intValue, intValue) ||
                other.intValue == intValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, intValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NotModifiedImplCopyWith<_$NotModifiedImpl> get copyWith =>
      __$$NotModifiedImplCopyWithImpl<_$NotModifiedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return notModified(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int intValue)? multipleChoice,
    TResult? Function(int intValue)? moved,
    TResult? Function(int intValue)? found,
    TResult? Function(int intValue)? seeOther,
    TResult? Function(int intValue)? notModified,
    TResult? Function(int intValue)? useProxy,
    TResult? Function(int intValue)? unused,
    TResult? Function(int intValue)? temporaryRedirect,
    TResult? Function(int intValue)? permanentRedirect,
  }) {
    return notModified?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (notModified != null) {
      return notModified(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return notModified(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MultipleChoice value)? multipleChoice,
    TResult? Function(_Moved value)? moved,
    TResult? Function(_Found value)? found,
    TResult? Function(_SeeOther value)? seeOther,
    TResult? Function(_NotModified value)? notModified,
    TResult? Function(_UseProxy value)? useProxy,
    TResult? Function(_Unused value)? unused,
    TResult? Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult? Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return notModified?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (notModified != null) {
      return notModified(this);
    }
    return orElse();
  }
}

abstract class _NotModified implements RestResponseRedirectCodeType {
  const factory _NotModified({final int intValue}) = _$NotModifiedImpl;

  @override
  int get intValue;
  @override
  @JsonKey(ignore: true)
  _$$NotModifiedImplCopyWith<_$NotModifiedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UseProxyImplCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$$UseProxyImplCopyWith(
          _$UseProxyImpl value, $Res Function(_$UseProxyImpl) then) =
      __$$UseProxyImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int intValue});
}

/// @nodoc
class __$$UseProxyImplCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res, _$UseProxyImpl>
    implements _$$UseProxyImplCopyWith<$Res> {
  __$$UseProxyImplCopyWithImpl(
      _$UseProxyImpl _value, $Res Function(_$UseProxyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intValue = null,
  }) {
    return _then(_$UseProxyImpl(
      intValue: null == intValue
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$UseProxyImpl implements _UseProxy {
  const _$UseProxyImpl(
      {this.intValue = RestResponseRedirectCodeType.useProxyIntValue});

  @override
  @JsonKey()
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.useProxy(intValue: $intValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UseProxyImpl &&
            (identical(other.intValue, intValue) ||
                other.intValue == intValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, intValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UseProxyImplCopyWith<_$UseProxyImpl> get copyWith =>
      __$$UseProxyImplCopyWithImpl<_$UseProxyImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return useProxy(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int intValue)? multipleChoice,
    TResult? Function(int intValue)? moved,
    TResult? Function(int intValue)? found,
    TResult? Function(int intValue)? seeOther,
    TResult? Function(int intValue)? notModified,
    TResult? Function(int intValue)? useProxy,
    TResult? Function(int intValue)? unused,
    TResult? Function(int intValue)? temporaryRedirect,
    TResult? Function(int intValue)? permanentRedirect,
  }) {
    return useProxy?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (useProxy != null) {
      return useProxy(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return useProxy(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MultipleChoice value)? multipleChoice,
    TResult? Function(_Moved value)? moved,
    TResult? Function(_Found value)? found,
    TResult? Function(_SeeOther value)? seeOther,
    TResult? Function(_NotModified value)? notModified,
    TResult? Function(_UseProxy value)? useProxy,
    TResult? Function(_Unused value)? unused,
    TResult? Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult? Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return useProxy?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (useProxy != null) {
      return useProxy(this);
    }
    return orElse();
  }
}

abstract class _UseProxy implements RestResponseRedirectCodeType {
  const factory _UseProxy({final int intValue}) = _$UseProxyImpl;

  @override
  int get intValue;
  @override
  @JsonKey(ignore: true)
  _$$UseProxyImplCopyWith<_$UseProxyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnusedImplCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$$UnusedImplCopyWith(
          _$UnusedImpl value, $Res Function(_$UnusedImpl) then) =
      __$$UnusedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int intValue});
}

/// @nodoc
class __$$UnusedImplCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res, _$UnusedImpl>
    implements _$$UnusedImplCopyWith<$Res> {
  __$$UnusedImplCopyWithImpl(
      _$UnusedImpl _value, $Res Function(_$UnusedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intValue = null,
  }) {
    return _then(_$UnusedImpl(
      intValue: null == intValue
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$UnusedImpl implements _Unused {
  const _$UnusedImpl(
      {this.intValue = RestResponseRedirectCodeType.unusedIntValue});

  @override
  @JsonKey()
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.unused(intValue: $intValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnusedImpl &&
            (identical(other.intValue, intValue) ||
                other.intValue == intValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, intValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnusedImplCopyWith<_$UnusedImpl> get copyWith =>
      __$$UnusedImplCopyWithImpl<_$UnusedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return unused(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int intValue)? multipleChoice,
    TResult? Function(int intValue)? moved,
    TResult? Function(int intValue)? found,
    TResult? Function(int intValue)? seeOther,
    TResult? Function(int intValue)? notModified,
    TResult? Function(int intValue)? useProxy,
    TResult? Function(int intValue)? unused,
    TResult? Function(int intValue)? temporaryRedirect,
    TResult? Function(int intValue)? permanentRedirect,
  }) {
    return unused?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (unused != null) {
      return unused(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return unused(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MultipleChoice value)? multipleChoice,
    TResult? Function(_Moved value)? moved,
    TResult? Function(_Found value)? found,
    TResult? Function(_SeeOther value)? seeOther,
    TResult? Function(_NotModified value)? notModified,
    TResult? Function(_UseProxy value)? useProxy,
    TResult? Function(_Unused value)? unused,
    TResult? Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult? Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return unused?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (unused != null) {
      return unused(this);
    }
    return orElse();
  }
}

abstract class _Unused implements RestResponseRedirectCodeType {
  const factory _Unused({final int intValue}) = _$UnusedImpl;

  @override
  int get intValue;
  @override
  @JsonKey(ignore: true)
  _$$UnusedImplCopyWith<_$UnusedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TemporaryRedirectImplCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$$TemporaryRedirectImplCopyWith(_$TemporaryRedirectImpl value,
          $Res Function(_$TemporaryRedirectImpl) then) =
      __$$TemporaryRedirectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int intValue});
}

/// @nodoc
class __$$TemporaryRedirectImplCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res,
        _$TemporaryRedirectImpl>
    implements _$$TemporaryRedirectImplCopyWith<$Res> {
  __$$TemporaryRedirectImplCopyWithImpl(_$TemporaryRedirectImpl _value,
      $Res Function(_$TemporaryRedirectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intValue = null,
  }) {
    return _then(_$TemporaryRedirectImpl(
      intValue: null == intValue
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$TemporaryRedirectImpl implements _TemporaryRedirect {
  const _$TemporaryRedirectImpl(
      {this.intValue = RestResponseRedirectCodeType.temporaryRedirectIntValue});

  @override
  @JsonKey()
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.temporaryRedirect(intValue: $intValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TemporaryRedirectImpl &&
            (identical(other.intValue, intValue) ||
                other.intValue == intValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, intValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TemporaryRedirectImplCopyWith<_$TemporaryRedirectImpl> get copyWith =>
      __$$TemporaryRedirectImplCopyWithImpl<_$TemporaryRedirectImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return temporaryRedirect(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int intValue)? multipleChoice,
    TResult? Function(int intValue)? moved,
    TResult? Function(int intValue)? found,
    TResult? Function(int intValue)? seeOther,
    TResult? Function(int intValue)? notModified,
    TResult? Function(int intValue)? useProxy,
    TResult? Function(int intValue)? unused,
    TResult? Function(int intValue)? temporaryRedirect,
    TResult? Function(int intValue)? permanentRedirect,
  }) {
    return temporaryRedirect?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (temporaryRedirect != null) {
      return temporaryRedirect(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return temporaryRedirect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MultipleChoice value)? multipleChoice,
    TResult? Function(_Moved value)? moved,
    TResult? Function(_Found value)? found,
    TResult? Function(_SeeOther value)? seeOther,
    TResult? Function(_NotModified value)? notModified,
    TResult? Function(_UseProxy value)? useProxy,
    TResult? Function(_Unused value)? unused,
    TResult? Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult? Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return temporaryRedirect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (temporaryRedirect != null) {
      return temporaryRedirect(this);
    }
    return orElse();
  }
}

abstract class _TemporaryRedirect implements RestResponseRedirectCodeType {
  const factory _TemporaryRedirect({final int intValue}) =
      _$TemporaryRedirectImpl;

  @override
  int get intValue;
  @override
  @JsonKey(ignore: true)
  _$$TemporaryRedirectImplCopyWith<_$TemporaryRedirectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PermanentRedirectImplCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$$PermanentRedirectImplCopyWith(_$PermanentRedirectImpl value,
          $Res Function(_$PermanentRedirectImpl) then) =
      __$$PermanentRedirectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int intValue});
}

/// @nodoc
class __$$PermanentRedirectImplCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res,
        _$PermanentRedirectImpl>
    implements _$$PermanentRedirectImplCopyWith<$Res> {
  __$$PermanentRedirectImplCopyWithImpl(_$PermanentRedirectImpl _value,
      $Res Function(_$PermanentRedirectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? intValue = null,
  }) {
    return _then(_$PermanentRedirectImpl(
      intValue: null == intValue
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$PermanentRedirectImpl implements _PermanentRedirect {
  const _$PermanentRedirectImpl(
      {this.intValue = RestResponseRedirectCodeType.permanentRedirectIntValue});

  @override
  @JsonKey()
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.permanentRedirect(intValue: $intValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PermanentRedirectImpl &&
            (identical(other.intValue, intValue) ||
                other.intValue == intValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, intValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PermanentRedirectImplCopyWith<_$PermanentRedirectImpl> get copyWith =>
      __$$PermanentRedirectImplCopyWithImpl<_$PermanentRedirectImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return permanentRedirect(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int intValue)? multipleChoice,
    TResult? Function(int intValue)? moved,
    TResult? Function(int intValue)? found,
    TResult? Function(int intValue)? seeOther,
    TResult? Function(int intValue)? notModified,
    TResult? Function(int intValue)? useProxy,
    TResult? Function(int intValue)? unused,
    TResult? Function(int intValue)? temporaryRedirect,
    TResult? Function(int intValue)? permanentRedirect,
  }) {
    return permanentRedirect?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (permanentRedirect != null) {
      return permanentRedirect(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return permanentRedirect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_MultipleChoice value)? multipleChoice,
    TResult? Function(_Moved value)? moved,
    TResult? Function(_Found value)? found,
    TResult? Function(_SeeOther value)? seeOther,
    TResult? Function(_NotModified value)? notModified,
    TResult? Function(_UseProxy value)? useProxy,
    TResult? Function(_Unused value)? unused,
    TResult? Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult? Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return permanentRedirect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (permanentRedirect != null) {
      return permanentRedirect(this);
    }
    return orElse();
  }
}

abstract class _PermanentRedirect implements RestResponseRedirectCodeType {
  const factory _PermanentRedirect({final int intValue}) =
      _$PermanentRedirectImpl;

  @override
  int get intValue;
  @override
  @JsonKey(ignore: true)
  _$$PermanentRedirectImplCopyWith<_$PermanentRedirectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
